# -*- shell-script -*-
#
# Copyright (C) 2005-2010 by John P. Weiss under the Artistic License
#
# RCS $Id: rc.kernel_cmdline 1439 2005-10-05 22:04:42Z candide $
############


. /etc/LocalSys/init.d/functions


isInPowersaveMode()
{
    # Return the envvar value if it was already set.
    if [ -n "$POWERSAVE" ]; then
	pstate=1
        if [ "$POWERSAVE" = "y" ]; then
            pstate=0
        fi
        return $pstate
    fi #else:

    # Determine the runlevel (if it hasn't been done yet).
    if [ -z "$RUNLEVEL" ]; then
        RUNLEVEL=`getRunlevel`
        export RUNLEVEL
    fi

    if [ "${RUNLEVEL:-2}" = "4" ]; then
        POWERSAVE='y'
	export POWERSAVE
        return 0
    fi #else:
    return 1
}


# Stolen from 'toggleAllWireless()' in '/usr/share/acpi-support/state-funcs'
# and modified.
disableAllWireless()
{
    status=0

    for DEVICE in /sys/class/net/* ; do
        if [ -d $DEVICE/wireless ] ; then
            # $DEVICE is a wireless device.

            FOUND=
            # This particular form of the sysfs interface reverses
            #the truth values.
            ON=1
            OFF=0
            for CONTROL in $DEVICE/device/rfkill/rfkill*/state; do
                if [ -w "$CONTROL" ]; then
                    FOUND=1

                    if [ "$(cat "$CONTROL")" = "$ON" ] ; then
                        # It's powered on. Switch it off.
                        echo -n "$OFF" > "$CONTROL" || status=1
                    fi # else
                       # It's powered off; ignore it.
                fi
            done
            # it might be safe to assume that a device only supports one
            # interface at a time; but just in case, we short-circuit
            # here to avoid toggling the power twice
            if [ -n "$FOUND" ]; then
                continue
            fi

            ON=0
            OFF=1  # 1 for rf_kill, 2 for power/state
            for CONTROL in $DEVICE/device/rf_kill $DEVICE/device/power/state;
            do
                if [ -w $CONTROL ] ; then
                    # We have a way of controlling the device, lets try
                    if [ "`cat $CONTROL`" = 0 ] ; then
                        # It's powered on. Switch it off.
                        if echo -n $OFF > $CONTROL; then 
                            break
                        elif [ "$OFF" = 2 ]; then
                            # Both "echo" commands failed.  Return error
                            # status.
                            status=1
                        else
                            OFF=2 # for power/state, second time around
                        fi
                    fi # else
                       # It's powered off; ignore it.
                fi
            done
        fi
    done

    return $status
}


removeWifiModules()
{
    # FIXME:  Not Ideal, but I want to think about how to redesign the
    # whole rc.powersave-modules mechanism.  See "rc.powersave-modules" for
    # the cannonical list of wifi modules to remove.
    rmmodsAll ipw2200 \
        lib80211_crypt_ccmp lib80211_crypt_tkip lib80211_crypt_wep \
        aes_i586 aes_generic deflate zlib_deflate twofish twofish_common \
        ctr camellia serpent blowfish cast5 des_generic xcbc rmd160 \
        sha1_generic sha256_generic sha512_generic crypto_null af_key
}


killWifi()
{
    disableAllWireless
    removeWifiModules
}


killBluetooth()
{
    local p

    for p in bluez kblue blueman; do
        /usr/bin/pkill $p
    done

    service bluetooth stop
    rmmodsAll bridge stp bnep hidp input_polldev
}


#################
#
#  End

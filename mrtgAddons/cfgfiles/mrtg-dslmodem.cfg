## The value of 'LogDir' in your "/etc/mrtg" configuration file.
##
MRTG.LogDir = /home/candide/tmp/mrtg-tst

## The name of the data log file under "MRTG.LogDir".  Don't include a path.
##
MRTG.Our_DataFile = m_connectivity.log

# FIXME:  #DBG#  For Debugging Purposes Only:
_DataFile = "/home/candide/tmp/mrtg-tst/mrtg-dslmodem.dat"
_DaemonPIDFile = "/home/candide/tmp/mrtg-tst/mrtg-dslmodem.pid"
_DaemonLog = "/home/candide/tmp/mrtg-tst/mrtg-dslmodem.log"
# Debugging Bits:
# 128 :== Low-level script operation.
#  64 :== Raw syslog reading & cleaned up HTML lines.
#  32 :== Syslog processing stages.
#  16 :== Activates HTML::TableExtract parser debug logging.
#   8 :== Display HTML Table extraction steps.
#   4 :== Display extracted HTML Table data and post-processing steps.
# !=0 :== Generic debug messages.
_DebugLoggingIsActive = 1


##
## Settings for a Speedstream 6520
## No authentication needed.
##

#UpdateInterval = 15m
#ModemAdjustsForDST = 0
#
#Syslog.Url = 'http://dsl/system.log'
#Syslog.DslDown_expr = 'DSL\s+[|]Link Down'
#Syslog.DslUp_expr = 'DSL\s+[|]Link [Uu]p'
#Syslog.TimeFormat = 'yyyy-mm-dd HH:MM:SS'
#
#Stats.Url = 'http://dsl/dslstatsx.htm'
##DBG#Stats.Url = 'file:///home/candide/src/perl/speedstream-dslstats.html'
### Change units to 1/10 of a db:
#Stats.AdjustUnits = (
#    10
#    10
#    10
#    10
##    1
##    1
##    .001
##    .001
#)
#Stats.Table.KeepIdx = 0
#Stats.Table.Column_exprs = (
#    'DS SNR'
#    'US SNR'
#    'DS Atten.'
#    'US Atten.'
#    '$undef^'
#    '$undef^'
#    '$undef^'
#    '$undef^'
#    'Rx .blocks.'
#    'Tx .blocks.'
#)


##
## Settings for an Actiontec GT784WN
## This DSL modem always requires authorization.
##

#UpdateInterval = 1h
# With a really bad connection, 1hr seems to be a bit too long.
# Try 45m or 30m instead.
#UpdateInterval = 45m
#DBG#
UpdateInterval = 5m

userid = user
passwd = a1222b026757298fdac557964a47c781d42ca2b06774755a
#GPG.SettingsFile = file

Syslog.Url = 'http://dsl/syslog.foo'
Syslog.DslDown_expr = 'ADSL link down'
Syslog.DslUp_expr = 'ADSL link up'
Syslog.TimeFormat = 'mm/dd/yyyy HH:MM:SS PM'

Stats.Url = 'http://dsl/statsadsl.html'
#DBG#Stats.Url = 'file:///home/candide/src/perl/actiontec-statsadsl.html'
Stats.Table.Column_exprs = (
    '[ \xA0]+'
    'Downstream'
    'Upstream'
)
Stats.Table.Row_exprs = (
    'SNR'
    'Attenuation'
    'Output Power'
    '\ARate'
    'Attain.*Rate'
)

####
## Alternate Stats Page, which uses Javascript to generate the results.
####
#Stats.Url = 'http://dsl/modemstatus_wanstatus.html'
##DBG#Stats.Url = 'file:///home/candide/src/perl/actiontec-wanstats.html'
#Stats.Manual.ExtractionRegexps = (
#    '.*var\s+dslstatus\s+=\s+(.*);.*\Z'
#)
#Stats.Manual.CleanupRegexps = (
#    "'"
#)
#Stats.Manual.Split = (
#    '[|/]'
#)
#Stats.Manual.Select = (
#    4
#    5
#    6
#    7
#    29
#    28
#    2
#    3
#)
#Stats.Manual.DisplayText = (
#    'SNR (0.1 dB) Downstream'
#    'SNR (0.1 dB) Upstream'
#    'Attenuation (0.1 dB) Downstream'
#    'Attenuation (0.1 dB) Upstream'
#    'Power (0.1 dBm) Downstream'
#    'Power (0.1 dBm) Upstream'
#    'Rate (Kbps) Downstream'
#    'Rate (Kbps) Upstream'
#)
## Change units to 1/10 of a db:
#Stats.AdjustUnits = (
#    10
#    10
#    10
#    10
#)


###########################
##                       ##
## Settings Descriptions ##
##                       ##
###########################


## List options have a special format:
## - A single '(' is the "value"
##   [i.e. it's the only thing on the line following the delimiter].
## - Each list item appears on the subsequent lines, one item per line.
##   + The item can be preceded or followed by any amount of whitespace, which
##     is ignored.
##   + Nothing follows the list item, no commas or other tokens.  The EOL
##     is the delimiter
## - There should be no empty lines.  To specify an "empty" list item, use a
##   lone pair of quotes.
## - A lone ')' should be on the line following the last item in the list.


##----------------------------------------------
## 'Stats' Group:   Collect DSL Modem statistics
##----------------------------------------------


## Url for the DSL modem's stats page.  Right now, only one is supported.
#Stats.Url = 'http://dsl/somepage.html'


## How to adjust the units of each statistics.  MRTG doesn't do
## floating-point, so you'll have to multiply the results by the appropriate
## factor of 10.
## 
## Each element in this list corresponds to the statistics collected by either
## the 'Stats.Table.*' or 'Stats.Manual.*' group of settings, below.  Each
## statistic, in the order returned in client mode, is multiplied by the
## corresponding value in the list below.
## 
## Any undefined value in this list (i.e. an empty string) or value of '0' is
## automatically changed to '1'.  You can, therefore, have fewer elements in
## this setting than the number of statistics collected.
##
## You can run 'mrtg-dslmodem.pl' using the '-n' option to see a list of the
## collected statistics.
#Stats.AdjustUnits = (
#    ''
#    :
#    ''
#)


##--------------------------------------------------------------------
## 'Stats.Table' Subgroup:   DSL Modem statistics are in HTML table(s)
##--------------------------------------------------------------------


## Table column headers to match.  Will be embedded in a regexp (so avoid
## "sensitive" characters like '[' or '(').
##
## The special value '$undef^' will be converted into a "placeholder-column"
## so that you can use the same MRTG configuration with any modem.
#Stats.Table.Column_exprs = (
#    ''
#    :
#    ''
#)

## Table row "headers" to match.  Will be embedded in a regexp (so avoid
## "sensitive" characters like '[' or '(') and matched against the first
## column in each row.
##
## The special value '$undef^' will be converted into a "placeholder-column"
## so that you can use the same MRTG configuration with any modem.
##
## When both this and 'Stats.Table.Column_exprs' are set, the data in every
## matcing row and column is returned.  The column headers and the first
## column of each row, however, are not (being labels and not data, after all).
##
## After processing, the data will be "flattened" into this form:
## 
##   (row1col1, row1col2, ... , row2col1, row2col2, ...)
##   
## Bear this in mind when retrieving the results in client mode.
#Stats.Table.Row_exprs = (
#    ''
#    :
#    ''
#)

## The index of the row of data to keep.  Defaults to 0 if not set.
## 
## When 'Stats.Table.Row_exprs' is set and 'Stats.Table.Column_exprs' is not,
## this becomes the column of data to keep.  The first column of the table
## is always a row header, and is removed before the data is selected.  So,
## if 'N' is the index of the _table_ column you want to keep, set this to
## 'N-1'.
##
## Ignored when both 'Stats.Table.Column_exprs' and 'Stats.Table.Row_exprs'
## are set.
#Stats.Table.KeepIdx = 0;

## Nested tables are treated as "layers".  This parameter specifies the depth
## of the layer containing the table(s) with the data.
## '0' is the top-level layer.
#Stats.Table.Depth = 0;

## The "position" of the table to select, i.e. where in the original HTML the
## desired table was defined.  If you want only the first table, set this to
## '0'.  The second table defined in the file would have the position '1',
## and so on. 
##
## When 'Stats.Table.Depth' is set, this value selects the table by its
## "position" at that depth.  So, setting this option to '3' when
## 'Stats.Table.Depth=1' selects the 4th table in the 2nd layer.
#Stats.Table.PositionInLayer = 0;

## A list of HTML tags that the table parser should ignore.  Defaults to
## "('style', 'script')".
#Stats.Table.IgnoreTags = (
#    ''
#    :
#    ''
#)


##--------------------------------------------------------------------
## 'Stats.Manual' Subgroup:   Extract the DSL Modem statistics "by hand"
##--------------------------------------------------------------------


## A list of Perl regular expressions that lines of the web page must match.
## Nonmatching lines are discarded.  The regexps are applied in-order, until
## one matches.
##
## Avoid putting capturing groups in these regexps.  If you must, use the
## "clustering group" delimiter, '(?:' ... ')'.
##
## Additionally, if any of the regexps in this list have errors in them,
## 'mrtg-dslmodem.pl' will die.  Consider running with the '-n' option first
## to test your regular expressions for errors.
##
## This group of regular expressions and 'Stats.Manual.ExtractionRegexps' are
## applied _first_, to the raw web page.  So, either this setting or
## 'Stats.Manual.ExtractionRegexps' (or both) must be a non-empty list.
#Stats.Manual.FilterRegexps = (
#    ''
#    :
#    ''
#)

## A list of Perl regular expressions that lines of the web page must match.
## Each regular expression MUST contain at least one capturing group.
##
## Like 'Stats.Manual.FilterRegexps', web page lines that don't match are
## discarded.  Unlike 'Stats.Manual.FilterRegexps', matching lines are replaced
## with the contents of the first regexp group.  If the matched group contains
## nothing but whitespace, then the original line is discarded, not modified.
## All of the regular expressions are tried, whether they match or not.
##
## NOTE:  This list of regular expressions is cumulative!  If more than one
## matches, each will be applied and the existing content replaced.  Therefore,
## design your expressions carefully.
##
## You can use this to both filter and trim down lines from the web page.
## It can be used in combination with 'Stats.Manual.FilterRegexps' or alone.
##
## Again, if any of the regexps in this list have errors in them,
## 'mrtg-dslmodem.pl' will die.  Consider running with the '-n' option first to
## test your regular expressions for errors.
##
## This group of regular expressions and 'Stats.Manual.FilterRegexps' are
## applied _first_, to the raw web page.  So, either this setting or
## 'Stats.Manual.FilterRegexps' (or both) must be a non-empty list.
#Stats.Manual.ExtractionRegexps = (
#    ''
#    :
#    ''
#)

## Cleanup is the second operation, performed after the filtering pass.  This
## setting contains regular expressions to _remove_completely_ from each line.
## It is an optional step; omit this setting to skip it.
##
## Each filtered line is checked against the regexps from this list, in order.
## Each one that matches is used in a substitution expression that looks like
## this:
## 
##     s¦(?:$YourRegexpHere)¦¦gi
##
## Note that the delimiters are the Latin-1 "brokenbar" character, so that you
## don't need to worry about having to escape '/' chars.
##
## After all of the regular expressions have been applied, if the line contains
## nothing but whitespace, it's discarded.
#Stats.Manual.CleanupRegexps = (
#    ''
#    :
#    ''
#)

## Splitting lines into fields is the third operation, performed after the
## cleanup pass.  This setting contains the regular expressions used to split
## the lines.  It, too, is optional; omit this setting to skip the splitting
## step.
##
## Processing occurs, one regexp at a time, in the order listed, as follows:
## - Each line from the previous pass is checked against the current regexp.
##   + Lines that don't match are skipped.
##   + Lines which do match are split.  The resulting fields become new
##     "lines", inserted into the list of lines at the position where their
##     "parent line" once was.
##   + Empty fields ARE inserted, since that might be meaningful.
## - Once every line has been processed, the next regexp is used for the next
##   pass.  Therefore, you can use more than one regexp to break apart a single
##   line.
##
## Run "perldoc -f spit" for a description of the types of regular expressions
## used to split lines into arrays.  There are limitations, and side-effects;
## 'mrtg-dslmodem.pl' will not check for them.
#Stats.Manual.Split = (
#    ''
#    :
#    ''
#)

## Selection of the actual statistics is the fourth operation.  This step is
## *NOT* optional.
##
## This setting contains a list of "things" used to select the actual values of
## each statistic.  The "things" can be either array indices (zero-offset) or
## regular expressions.  They should be listed in the order that you want the
## matching statistic to appear in the results-data.
##
## The indices are used first, to slice out the desired elements from the list
## of "lines" created by the previous operations.  After that, the regexps are
## tested, one by one, against the remaining elements.  The first one that
## matches is chosen as the statistic.  If there's no match, the statistic at
## that position is set to -1.
##
## If you are debugging your regular expressions, just set one of the elements
## of this list to '*'.  'mrtg-dslmodem.pl -n' will then select (almost) all
## of the "lines" remaining after processing.  (There is a large internal
## upper limit, but the output would be pretty useless if you've actually kept
## that many lines.)
##
## FIXME:  Dunno about capturing groups in the regexps.  Gotta see if Perl has
## some way to check the $<n> vars easily.
##
#Stats.Manual.Select = (
#    ''
#    :
#    ''
#)

## Custom display text for the selected stats.
##
## Each element in this setting is the label for the corresponding element in
## 'Stats.Manual.Select'.  It will be used as the display text for
## debug-logging and when running 'mrtg-dslmodem.pl -n'.
##
## Since it's just for human-readable output, this setting is optional.  By
## default, the human-readable labels for the selected stats are constructed.
##
## If there are more elements in this setting than 'Stats.Manual.Select', the
## extras are ignored.  If there are fewer elements than in
## 'Stats.Manual.Select', the "missing" ones are constructed in the default
## manner.
##
## Make sure that every element in this list is UNIQUE.  You'll mess up stats
## selection if you don't!
##
#Stats.Manual.DisplayText = (
#    ''
#    :
#    ''
#)
